Hello, today's video is hopefully short, and it is an addendum to :

(show youtube title)

Rust Programming Part 2 HTTP Server Using Result Type & Responding To Client

So I guess this is Part2a.

In Part 2, we handled sending an OK response from the http server, back to client.
We saw that response when we used the curl command.

But what I forgot to do is to first  read the http request from the client.

So we'll do that now, as it introduces other things to learn about Rust.


-----------------------------------------------------------------------------------
First, let's briefly go over how we left the code last, and run it.

The main point  here is that we see the OK response in our curl window.

But we don't see anything related to the original request in our server window.


-----------------------------------------------------------------------------------
The first thing to do then is a read from the stream.

    stream.read();

error[E0599]: no method named `read` found for type `std::net::TcpStream` in the current scope
  --> src/main.rs:48:12
   |
48 |     stream.read();
   |            ^^^^ method not found in `std::net::TcpStream`
   |
   = help: items from traits can only be used if the trait is in scope
help: the following trait is implemented but not in scope; perhaps add a `use` for it:
   |
2  | use std::io::Read;
   |

-----------------------------------------------------------------------------------

  2 use std::net::TcpListener;
  3 use std::net::TcpStream;
  4 use std::io::Read;
  5 use std::io::Write;
  6 use std::io::Error;


error[E0061]: this function takes 1 parameter but 0 parameters were supplied
  --> src/main.rs:49:12
   |
49 |     stream.read();
   |            ^^^^ expected 1 parameter


-----------------------------------------------------------------------------------
The parameter expected is some sort of buffer that will hold the incoming request.

We should assume that the incoming request data is more than a single value.
We know that curl sends a "HEAD / HTTP/1.1";  that's several bytes of data.

That means we need some sort of array.

Let's try this for now:

 49     let request = [];
 50
 51     stream.read(request);
 
   |
51 |     stream.read(request);
   |                 ^^^^^^^
   |                 |
   |                 expected `&mut [u8]`, found array of 0 elements
   |                 help: consider mutably borrowing here: `&mut request`
   |
   = note: expected mutable reference `&mut [u8]`
                          found array `[_; 0]`

-----------------------------------------------------------------------------------
Again we see how Rust is very careful about memory.  The key phrase in the error is:

"consider mutably borrowing here: '&mut request'"

 51     stream.read(&mut request);


error[E0596]: cannot borrow `request` as mutable, as it is not declared as mutable
  --> src/main.rs:51:17
   |
49 |     let request = [];
   |         ------- help: consider changing this to be mutable: `mut request`
50 |
51 |     stream.read(&mut request);
   |                 ^^^^^^^^^^^^ cannot borrow as mutable


-----------------------------------------------------------------------------------
let's make our new array declaration mutable.

 49     let mut request = [];


warning: unused `std::result::Result` that must be used
  --> src/main.rs:51:5
   |
51 |     stream.read(&mut request);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 1.79s
     Running `target/debug/http_server`
Starting server....
TcpListener { addr: V4(127.0.0.1:8594), fd: 3 }
Server listening for http://localhost:8594



It's interesting that it is running - we haven't yet hit it with curl so we dont know how it
will react since we have declared an empty array.

The above warning we have seen before - the read operation returns a Resutl, so Ok or Error,
and we need to handle it.

Before we do that, let's go ahead and hit it with a request from curl.


Starting server....
TcpListener { addr: V4(127.0.0.1:8594), fd: 3 }
Server listening for http://localhost:8594
Got incoming connection request...
Ok(TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59432), fd: 4 })
Handling request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59432), fd: 4 }
Inside handle_client_request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59432), fd: 4 }


EliezerC@L07705EliezerC MINGW64 ~
$ curl -s -I http://localhost:8594
HTTP/1.1 200 OK



No apparent errors or blow up.



-----------------------------------------------------------------------------------
Since we are trying to read the incoming request string, the only thing we're going
to do with it is print it to our server window.

First, though, let's handle that warning for the Result Ok or Error.

 51     let req_result = stream.read(&mut request);
 52     match req_result {
 53         Ok(ok_var) => println!("OK:  {:?}", ok_var),
 54         Err(err_var) => println!("Err:  {:?}", err_var),
 55     }


Ok, it ran and no warnings.

-----------------------------------------------------------------------------------
Now let's work on displaing the incoming request string to the server window.

 57     println!("Incoming request: {:?}", request);


Starting server....
TcpListener { addr: V4(127.0.0.1:8594), fd: 3 }
Server listening for http://localhost:8594
Got incoming connection request...
Ok(TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59537), fd: 4 })
Handling request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59537), fd: 4 }
Inside handle_client_request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59537), fd: 4 }
OK:  0
Incoming request: []
After handle Ok:  20


So it didnt blow , just didn't capture anything - since we declared an empty array.

-----------------------------------------------------------------------------------
What if we give the array some size?


 49     let mut request = [0;5];
 50     println!("New request array : {:?}", request);
 51
 52     let req_result = stream.read(&mut request);
 53     match req_result {
 54         Ok(ok_var) => println!("OK:  {:?}", ok_var),
 55         Err(err_var) => println!("Err:  {:?}", err_var),
 56     }
 57
 58     println!("Incoming request: {:?}", request);
 


Starting server....
TcpListener { addr: V4(127.0.0.1:8594), fd: 3 }
Server listening for http://localhost:8594
Got incoming connection request...
Ok(TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59607), fd: 4 })
Handling request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59607), fd: 4 }
Inside handle_client_request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59607), fd: 4 }
New request array : [0, 0, 0, 0, 0]
OK:  5
Incoming request: [72, 69, 65, 68, 32]
After handle Ok:  20


-----------------------------------------------------------------------------------
The compiler seems to have inferred the type of array based on the initialization.

Seems like we have some bytes.  We want to turn that into something meaningful.

There are probably way better ways to do this, but one way I found is to attempt
a method that may not exist, and we then get the type from the compiler.

like so:

 58     println!("Incoming request: {:?}", request);
 59
 60     println!("Incoming request: {:?}", request.unwrap());
 

error[E0599]: no method named `unwrap` found for type `[u8; 5]` in the current scope
  --> src/main.rs:60:48
   |
60 |     println!("Incoming request: {:?}", request.unwrap());
   |                                                ^^^^^^ method not found in `[u8; 5]`


So now we know that we have a byte array .   8-bit bytes.  Not integer array.


-----------------------------------------------------------------------------------
Let's try converting the byte array into a string or somethjng like that.

After some researching:

 60     let btyes_to_string = std::str::from_utf8(request);

error[E0308]: mismatched types
  --> src/main.rs:60:47
   |
60 |     let btyes_to_string = std::str::from_utf8(request);
   |                                               ^^^^^^^
   |                                               |
   |                                               expected `&[u8]`, found array `[u8; 5]`
   |                                               help: consider borrowing here: `&request`


-----------------------------------------------------------------------------------
 60     let btyes_to_string = std::str::from_utf8(&request);

warning: unused variable: `btyes_to_string`
  --> src/main.rs:60:9
   |
60 |     let btyes_to_string = std::str::from_utf8(&request);
   |         ^^^^^^^^^^^^^^^ help: consider prefixing with an underscore: `_btyes_to_string`
   |
   = note: `#[warn(unused_variables)]` on by default

-----------------------------------------------------------------------------------
no warnings.  let's print that new string:

 58     println!("Incoming request bytes: {:?}", request);
 59
 60     let _btyes_to_string = std::str::from_utf8(&request);
 61
 62     println!("Incoming request string: {:?}", _bytes_to_string);
 

Starting server....
TcpListener { addr: V4(127.0.0.1:8594), fd: 3 }
Server listening for http://localhost:8594
Got incoming connection request...
Ok(TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59861), fd: 4 })
Handling request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59861), fd: 4 }
Inside handle_client_request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59861), fd: 4 }
New request array : [0, 0, 0, 0, 0]
OK:  5
Incoming request bytes: [72, 69, 65, 68, 32]
Incoming request string: Ok("HEAD ")
After handle Ok:  20


Ok, we got back a   "OK("HEAD ")".   Interesting. Even though we are printing a string(?) ,
it's an "OK()" wrapping a string.


-----------------------------------------------------------------------------------
So, let's try UNwrapping that Ok().

 58     println!("Incoming request bytes: {:?}", request);
 59
 60     let _bytes_to_string = std::str::from_utf8(&request);
 61
 62     println!("Incoming request string: {:?}", _bytes_to_string);
 63
 64     let _unwrapped_string = _bytes_to_string.unwrap();
 65
 66     println!("Incoming request string: {:?}", _unwrapped_string);


New request array : [0, 0, 0, 0, 0]
OK:  5
Incoming request bytes: [72, 69, 65, 68, 32]
Incoming request string: Ok("HEAD ")
Incoming request string: "HEAD "
After handle Ok:  20


And we get the "HEAD" portion of the request by itself.  Pretty cool.

-----------------------------------------------------------------------------------
Now, the next thing is that we did not get the entire incoming request string.

So let's increase that byte array size.

How about we go for a size of 100 bytes?

 49     let mut request = [0;100];

error[E0277]: arrays only have std trait implementations for lengths 0..=32
  --> src/main.rs:50:42
   |
50 |     println!("New request array : {:?}", request);
   |                                          ^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[{integer}; 100]`
   |



-----------------------------------------------------------------------------------
As it turns out, unless we more into Rust, we are limited to a size of 32.

 49     let mut request = [0;32];


Inside handle_client_request....TcpStream { addr: V4(127.0.0.1:8594), peer: V4(127.0.0.1:59951), fd: 4 }
New request array : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
OK:  32
Incoming request bytes: [72, 69, 65, 68, 32, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10, 72, 111, 115, 116, 58, 32, 108, 111, 99, 97, 108, 104, 111, 115, 116]
Incoming request string: Ok("HEAD / HTTP/1.1\r\nHost: localhost")
Incoming request string: "HEAD / HTTP/1.1\r\nHost: localhost"
After handle Ok:  20


Seems the size 32 was just enough to grab most of the incoming HTTP request.



-----------------------------------------------------------------------------------

Anyway... we shall leave things here.

Next time we shall move onto something new, but related.


